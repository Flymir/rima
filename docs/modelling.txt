    --! env rima = require("rima")

# Rima Manual: Optimization Models

[ [Contents](contents.html) | Previous: [Tabulation](tabulation.html) | Next: [Scopes](scopes.html) ]

Rima's expressions can be used to express constraints and objectives in
Linear and Mixed-Integer Programs,
which can then be solved with one of the solvers Rima has bindings for.

Examples of solving LPs can be found in the examples directory.

The way a problem is constructed is likely to change, often, as Rima evolves.

Because Rima expressions are symbolic, and because references are can be bound to data
at any time (particularly late), you can express your problem in a very concise form,
and use the same problem description (or *formulation*) on many sets of data.


## Constructing a Model

A model formulation is just a scope we're going to structure in a special way.
`rima.new` provides a shortcut for constructing a new scope:

    f = rima.new()

`rima.mp.C` creates a new constraint, which we add to the formulation just like
any other value we add to the scope:

    --! continue
    x, y = rima.R"x, y"
    f.c1 = rima.mp.C(x + 2*y, "<=", 3)
    f.c2 = rima.mp.C(2*x + y, "<=", 3)

The objective and optimisation sense are also just values we set in the scope:

    --! continue
    f.objective = x + y
    f.sense = "maximise"

The string setting the objective sense is not case-sensitive, and can be
maximise, maximize, minimise or minimize.

You can set several variable in a scope at once with `rima.set`:

    --! continue
    rima.set(f, { ["x, y"] = rima.positive() })

`rima.mp` is the module that handles math programming.
It has functions to write a model readably:

    --! continue
    rima.mp.write(f)
    --> Maximise:
    -->   x + y
    --> Subject to:
    -->   c1: x + 2*y <= 3
    -->   c2: 2*x + y <= 3


## Solving a Model

And you can solve a formulation using a solver:

    --! continue
    primal, dual = rima.mp.solve("lpsolve", f)

The are two results, `objective` is, as expected is the objective,
and `r` is a table with variable and constraint values,
organised the same way as you put them in.

    --! continue
    print(primal.objective)                             --> 2

`r` mimics the structure of the undefined variables and constraints in the model formulation.
Each entry in variables is a table with two values: `p` (primal) the optimal value of the variable
and `d` the optimal dual (or reduced cost):

    --! continue
    print(primal.x, primal.y)                           --> 1 1
    print(dual.x, dual.y)                               --> 0 0

Likewise for the constraints:

    --! continue
    print(primal.c1, primal.c2)                         --> 3 3
    print(dual.c2, dual.c2)                             --> /0%.3+ 0%.3+/ 0.3333 0.3333


## Model Instances

`rima.instance(f)` creates a new model with the old model as a parent.
The new model has the same set of constraints and the same objective as the parent model,
but its scope is a child of the parent model's scope.

For examples of how this can be used for a rough stab at model composition, see
the examples listed on the [contents page](contents.html).

[ [Contents](contents.html) | Previous: [Tabulation](tabulation.html) | Next: [Scopes](scopes.html) ]
