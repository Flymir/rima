    --! env rima = require("rima") io = require("io")

# Rima Manual: Scopes

[ [Contents](contents.html) | Previous: [Optimization Models](modelling.html) ]

The variable values we've passed to `rima.E` have been standard Lua tables,
but before using them, Rima converts them into a `scope`.
A `scope` is pretty much like a Lua table, but they're write once:

    S = rima.scope.new()
    S.a = 5
    S.a = 6                                             --!
    --> scope: cannot set 'a' to '6': existing definition as '5'

You can set values in a scope to be types as well as literal data:

    --! continue
    S.b = rima.integer()
    print(S.b)                                          --> b

There's shorthand for creating scopes like table constructors,
with the addition that you can set several values at once:

    S = rima.scope.create{ ["a, b, c"]=5, ["x, y"]=rima.free() }
    print(S.a, S.b, S.x)                                --> 5 5 x

You can create complex structures with scopes:

    S = rima.scope.create{ a = {} }
    S.a.b.c = {}
    r = S.a.b.c
    r.d = 5
    print(S.a.b.c.d)                                    --> 5

You can create children of scopes: they inherit values from their parent,
and you can set values in them.
You still can't overwrite a value in a parent scope,
but you can overwrite a type, if you meet its constraints:

    S1 = rima.scope.create{ one=1, a=rima.integer() }
    S2 = rima.scope.spawn(S1)
    S3 = rima.scope.spawn(S1)
    print(S1.one, S2.one, S3.one)                       --> 1 1 1
    S2.a = 1.5                                          --!
    --> scope: cannot set 'a' to '1.5': violates existing constraint '0 <= * <= inf, * integer'
    S2.a = 3
    print(S1.a, S2.a, S3.a)                             --> a 3 a

[ [Contents](contents.html) | Previous: [Optimization Models](modelling.html) ]
